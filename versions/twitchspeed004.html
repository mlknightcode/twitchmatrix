<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Twitch Matrix — Two-Phase (Retrieve & Generate)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --accent: #9146FF; }
    * { box-sizing: border-box; }
    body {
      font-family: Arial, sans-serif;
      background: #1d1d1f;
      color: #f5f5f7;
      padding: 20px;
      margin: 0;
    }
    .container { display: flex; flex-direction: column; align-items: center; text-align: center; gap: 8px; }
    h1 { margin: 4px 0 0; font-size: 22px; }
    p.sub { margin: 0 0 8px; color: #bdbdbf; font-size: 14px; }
    .online { color: #3dfb55; }
    .offline { color: #ff6b6b; }
    .unknown { color: #9e9ea1; }
    .pinned { border: 1px solid #ffd54a; padding: 1px 3px; border-radius: 4px; }
    .blacklisted { border: 1px solid #ff7dbf; padding: 1px 3px; border-radius: 4px; }

    .controls { display: flex; flex-direction: column; gap: 10px; align-items: center; margin-top: 6px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; align-items: center; }
    .controls label {
      display: flex; align-items: center; gap: 6px;
      background: #2a2a2e; border: 1px solid #2f2f35; border-radius: 10px;
      padding: 6px 10px; font-size: 14px;
    }
    .controls input[type="text"] {
      padding: 6px 8px; width: 84px; border-radius: 8px; border: 1px solid #3a3a41;
      background: #19191b; color: #f5f5f7;
    }
    .btn {
      padding: 10px 16px; font-size: 15px; background-color: var(--accent);
      color: white; border: none; cursor: pointer; border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.25);
    }
    .btn.secondary { background: #2f2f35; color: #f5f5f7; }
    .btn:disabled { background-color: #555; cursor: not-allowed; }
    .btn:hover:enabled { filter: brightness(1.05); }

    .grid {
      display: flex; justify-content: center; gap: 30px; margin-top: 16px; flex-wrap: wrap;
    }
    /* Remove background/borders on tiers as requested */
    .tier { display: flex; flex-direction: column; align-items: stretch; min-width: 280px; border: none; background: transparent; padding: 0; }
    .tier h3 { text-align: left; margin: 0 0 8px; font-size: 16px; color: #d6d6d8; }
    .streamer { display: flex; align-items: center; gap: 6px; margin: 2px 0; padding: 2px 4px; border-radius: 8px; }
    /* No hover background */
    .status { margin-top: 16px; text-align: center; color: #bdbdbf; font-size: 14px; min-height: 20px; }

    .pin-btn, .black-btn {
      border: none; background: #2a2a2e; color: #f5f5f7;
      cursor: pointer; font-size: 14px; padding: 4px 6px; border-radius: 6px; line-height: 1;
    }
    .pin-btn.active { background: #2a3a1f; color: #b2ff59; }
    .black-btn.active { background: #3a1f2f; color: #ff7dbf; }

    /* in-flight indicator */
    .working { color: #9cf; position: relative; padding-left: 14px; }
    .working::before {
      content: ""; position: absolute; left: 0; top: 50%;
      width: 10px; height: 10px; margin-top: -5px;
      border: 2px solid currentColor; border-top-color: transparent;
      border-radius: 50%; animation: spin 0.8s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* picked indicator: simple yellow asterisk */
    .selected::after { content: " *"; color: #ffd54a; font-weight: 700; }

    .links { display: flex; gap: 10px; justify-content: center; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Twitch Matrix — Two-Phase</h1>
    <p class="sub">Retrieve fetches statuses for every name via batched call. Generate picks from cached results without new network calls.</p>

    <div class="controls">
      <!-- Row 1: size, limits, batch -->
      <div class="row">
        <label>Size <input type="text" id="inputSize" value="6" aria-label="Grid size"></label>
        <label>Limits (4 digits) <input type="text" id="inputLimits" value="6000" maxlength="4" aria-label="Tier limits"></label>
        <label>Batch <input type="text" id="inputBatch" value="5" aria-label="Batch size"></label>
      </div>
      <!-- Row 2: random checkboxes -->
      <div class="row">
        <label><input type="checkbox" id="rand1"> Random Tier 1</label>
        <label><input type="checkbox" id="rand2"> Random Tier 2</label>
        <label><input type="checkbox" id="rand3"> Random Tier 3</label>
        <label><input type="checkbox" id="rand4"> Random Tier 4</label>
      </div>
      <!-- Row 3: Retrieve & Generate -->
      <div class="row">
        <button class="btn secondary" id="retrieveBtn" title="Fetch statuses for all names">Retrieve</button>
        <button class="btn" id="generateBtn" title="Pick from the cached results only">Generate</button>
      </div>
      <!-- Row 4: Open links -->
      <div class="row links">
        <button class="btn secondary" disabled id="openLink">Open TwitchTheater</button>
        <button class="btn secondary" disabled id="openMulti">Open MultiTwitch</button>
      </div>
    </div>
  </div>

  <div class="grid" id="gridContainer"></div>
  <div class="status" id="status">Idle. Grid is ready.</div>

<script>
/* ---- Tiers ---- */
const tier1 = ["jinnytty","extraemily","bonnie","qtcinderella","emiru","knut","onigiri","mhyochi","jaystreazy","waterlynn","jakenbakelive","lo3tus","rennsz","hachubby","crispyjenny","jellyhaeni","hazunats","aprylanonymous","potentialbliss","hippiefix","ibabyrainbow","magicallyconsumed","recharg_ing","chloe__irl","kumamonster","dinomitetwins","nezst","jonsf","daveezz","studytme","jengo_m","ninthchild","bawnsai","ira_aba","justketh"];
const tier2 = ["yoshimyan","mizkif","juliakins","lizzy_senrose","cherlosthome","hello_kiko","fuslie","hitch","sarahbridgewater","therealshookon3","4amlaundry","nessalpaca","rellik","clararline","melibela","arrav","cooksux","meesterkeem","soleastellaa","globiklive","manukiemi","misterarther","cinna","robcdee","ridetheline","poultry_motion","fido_tw","d3nduro","stephaniequatro","foxiekt","classic_christine","wasabiicat","lychee","kiwhiskey"];
const tier3 = ["dskoopa","voyagesdiary","tiffanobi","gaijin1up","nomadicgaijin","yubababoo","thecranecouple","cybersteffie","gogoborgor","terrybarentsen","sahranisworld","miki_tokyo","claraatwork","mrpol","barktok","missmikkaa","nmplol","ppim","zumi","kydeanderic","botezlive","danioskam","crunk_muffin","architecturetv"];
const tier4 = ["maimaittv","wolfsbanee","soweq","tymwits","jinritv","relit20","awkwards_travel","crack_eggs","miekii","0greprincess","bottlehead","yurijoa","igumdrop","henukei","liniwalks","cecehustle","tokidokitraveller","w3cj","arianakatana","slipstreamjc","retrogaijin","dizzykitten","donutkingtv","zep_aki","agctv","hapipy","eddy2travel","mewmelodys"];
const tiers = [tier1, tier2, tier3, tier4];

/* ---- Twitch GraphQL ---- */
const clientId = "kimne78kx3ncx6brgo4mv6wki5h1ko";
const query = `query($login: String!) {
  user(login: $login) {
    stream {
      id
      game { name }
    }
  }
}`;

/* ---- Global State ---- */
const statusEl = document.getElementById("status");
const openBtn = document.getElementById("openLink");
const multiBtn = document.getElementById("openMulti");
let finalURL = "", multiURL = "";
const resultsCache = new Map(); // name -> {isLive, category}

/* ---- Helpers ---- */
function getPinList() {
  return new Set([...document.querySelectorAll(".pin-btn.active")].map(btn => btn.dataset.name));
}
function getBlacklist() {
  return new Set([...document.querySelectorAll(".black-btn.active")].map(btn => btn.dataset.name));
}
function abbreviateCategory(cat) {
  return cat.split(/\s+/).map(w => w.slice(0, 3)).join(" ");
}
function shuffledCopy(arr) {
  return [...arr].map(value => ({ value, sort: Math.random() }))
                 .sort((a, b) => a.sort - b.sort)
                 .map(({ value }) => value);
}
function getBatchSize() {
  const raw = document.getElementById("inputBatch")?.value ?? "5";
  const n = parseInt(raw, 10);
  return Number.isFinite(n) && n > 0 ? n : 5;
}

/* ---- Grid ---- */
function setupGrid() {
  const grid = document.getElementById("gridContainer");
  grid.innerHTML = "";
  tiers.forEach((tier, idx) => {
    const col = document.createElement("div");
    col.className = "tier";
    col.innerHTML = `<h3>Tier ${idx + 1}</h3>`;
    tier.forEach(name => {
      const row = document.createElement("div");
      row.className = "streamer";

      const pinBtn = document.createElement("button");
      pinBtn.className = "pin-btn";
      pinBtn.innerText = "✔";
      pinBtn.title = "Pin (prefer in selection)";
      pinBtn.dataset.name = name;
      pinBtn.onclick = () => {
        pinBtn.classList.toggle("active");
        blackBtn.classList.remove("active");
        updateStyle(name);
      };

      const blackBtn = document.createElement("button");
      blackBtn.className = "black-btn";
      blackBtn.innerText = "✖";
      blackBtn.title = "Blacklist (exclude from selection)";
      blackBtn.dataset.name = name;
      blackBtn.onclick = () => {
        blackBtn.classList.toggle("active");
        pinBtn.classList.remove("active");
        updateStyle(name);
      };

      const span = document.createElement("span");
      span.id = `status-${name}`;
      span.textContent = name;
      span.className = "unknown";

      row.append(pinBtn, blackBtn, span);
      col.appendChild(row);
    });
    grid.appendChild(col);
  });
}
function updateStyle(name) {
  const span = document.getElementById(`status-${name}`);
  if (!span) return;
  span.classList.remove("pinned", "blacklisted");
  if (document.querySelector(`.pin-btn[data-name="${name}"]`)?.classList.contains("active")) {
    span.classList.add("pinned");
  }
  if (document.querySelector(`.black-btn[data-name="${name}"]`)?.classList.contains("active")) {
    span.classList.add("blacklisted");
  }
}

/* ---- Indicators ---- */
function setWorking(names, isWorking) {
  for (const name of names) {
    const el = document.getElementById(`status-${name}`);
    if (!el) continue;
    el.classList.toggle("working", isWorking);
    el.setAttribute("aria-busy", isWorking ? "true" : "false");
    if (isWorking) {
      el.classList.remove("online", "offline", "unknown", "selected");
      el.textContent = `${name} (checking…)`;
    }
  }
}
function markError(names, note = "(error)") {
  for (const name of names) {
    const el = document.getElementById(`status-${name}`);
    if (!el) continue;
    el.classList.remove("working", "online", "offline", "selected");
    el.classList.add("unknown");
    el.setAttribute("aria-busy", "false");
    el.textContent = `${name} ${note}`;
  }
}
function paintLabel(name, r) {
  const span = document.getElementById(`status-${name}`);
  if (span) {
    span.classList.remove("working", "online", "offline", "unknown");
    if (!r) { span.classList.add("unknown"); span.textContent = name; return; }
    span.classList.add(r.isLive ? "online" : "offline");
    span.textContent = r.isLive && r.category ? `${name} (${abbreviateCategory(r.category)})` : name;
  }
}
function setSelected(name, isSelected) {
  const el = document.getElementById(`status-${name}`);
  if (!el) return;
  el.classList.toggle("selected", isSelected);
}
function clearSelected() {
  document.querySelectorAll(".selected").forEach(el => el.classList.remove("selected"));
}

/* ---- Ordering ---- */
function orderedTierNames(i, pinned, blacklist, tierRandomize) {
  const tier = tiers[i];
  const pinsFirst = tier.filter(n => pinned.has(n));
  const rest = tier.filter(n => !pinned.has(n));
  const ordered = tierRandomize[i] ? [...pinsFirst, ...shuffledCopy(rest)] : [...pinsFirst, ...rest];
  return ordered.filter(n => !blacklist.has(n));
}

/* ---- Networking ---- */
async function fetchBatch(names) {
  if (!names.length) return [];
  const ops = names.map(name => ({
    operationName: null,
    query,
    variables: { login: name }
  }));
  const res = await fetch("https://gql.twitch.tv/gql", {
    method: "POST",
    headers: {
      "Client-ID": clientId,
      "Content-Type": "application/json"
    },
    body: JSON.stringify(ops)
  });
  const data = await res.json();
  return data.map(d => {
    const stream = d?.data?.user?.stream;
    return {
      isLive: !!stream,
      category: stream?.game?.name || null
    };
  });
}

/* ---- Phase 1: Retrieve (fetch all) ---- */
async function retrieveAll() {
  statusEl.textContent = "Retrieving statuses for all names (batched)…";
  const allNames = [...new Set(tiers.flat())]; // union across tiers
  const batchSize = getBatchSize();
  let processed = 0;

  for (let idx = 0; idx < allNames.length; ) {
    const chunk = allNames.slice(idx, idx + batchSize);
    idx += batchSize;
    setWorking(chunk, true);
    try {
      const fetched = await fetchBatch(chunk);
      fetched.forEach((r, j) => {
        const name = chunk[j];
        resultsCache.set(name, r);
        paintLabel(name, r);
      });
      processed += chunk.length;
      statusEl.textContent = `Retrieved ${processed}/${allNames.length}…`;
    } catch (e) {
      console.error("Batch fetch error", e);
      markError(chunk);
    } finally {
      setWorking(chunk, false);
    }
  }
  statusEl.textContent = "Retrieve complete. Click Generate to pick from cache.";
}

/* ---- Phase 2: Generate from cache ---- */
function generateFromCache() {
  clearSelected(); // allow re-pick on repeated clicks
  const size = parseInt(document.getElementById("inputSize").value || "6", 10);
  const limitsRaw = document.getElementById("inputLimits").value || "6000";
  const tierLimits = limitsRaw.padEnd(4, "0").slice(0, 4).split("").map(n => parseInt(n, 10));

  const tierRandomize = [
    document.getElementById("rand1").checked,
    document.getElementById("rand2").checked,
    document.getElementById("rand3").checked,
    document.getElementById("rand4").checked
  ];
  const pinned = getPinList();
  const blacklist = getBlacklist();

  if (!resultsCache.size) {
    statusEl.textContent = "No cached statuses. Click ‘Retrieve’ first.";
    openBtn.disabled = true; multiBtn.disabled = true;
    return;
  }

  // Prepare ordered, filtered lists
  const perTierOrdered = [0,1,2,3].map(i => orderedTierNames(i, pinned, blacklist, tierRandomize));

  const usedTiers = [];
  const live = [];
  const tierLiveCounts = [0, 0, 0, 0];

  // Pass 1: respect per-tier limits
  for (let i = 0; i < perTierOrdered.length && live.length < size; i++) {
    const limit = tierLimits[i];
    if (limit <= 0) continue;
    for (const name of perTierOrdered[i]) {
      if (live.length >= size) break;
      if (tierLiveCounts[i] >= limit) break;
      const r = resultsCache.get(name);
      if (r?.isLive) {
        tierLiveCounts[i]++;
        live.push(name);
        setSelected(name, true);
        if (!usedTiers.includes(`Tier ${i + 1}`)) usedTiers.push(`Tier ${i + 1}`);
      }
    }
  }

  // Pass 2: ignore per-tier limits to fill remaining
  if (live.length < size) {
    for (let i = 0; i < perTierOrdered.length && live.length < size; i++) {
      for (const name of perTierOrdered[i]) {
        if (live.includes(name)) continue;
        const r = resultsCache.get(name);
        if (r?.isLive) {
          live.push(name);
          setSelected(name, true);
          if (!usedTiers.includes(`Tier ${i + 1}`)) usedTiers.push(`Tier ${i + 1}`);
          if (live.length >= size) break;
        }
      }
    }
  }

  if (live.length) {
    finalURL = `https://twitchtheater.tv/${live.join("/")}`;
    multiURL = `https://multitwitch.tv/${live.join("/")}`;
    openBtn.disabled = false;
    multiBtn.disabled = false;
    statusEl.innerHTML = `<strong>Picked ${live.length}/${size}</strong> from: ${usedTiers.join(", ")} (re-click Generate to re-pick)`;
  } else {
    statusEl.textContent = "No live streamers matched the selection rules. Try toggling random or pins, or change limits.";
    openBtn.disabled = true; multiBtn.disabled = true;
  }
}

/* ---- Wire up ---- */
document.addEventListener("DOMContentLoaded", () => {
  setupGrid();
  statusEl.textContent = "Idle. Grid is ready. Click ‘Retrieve’ to fetch statuses.";
  document.getElementById("retrieveBtn").onclick = retrieveAll;
  document.getElementById("generateBtn").onclick = generateFromCache;
  openBtn.onclick = () => finalURL && window.open(finalURL, "_blank");
  multiBtn.onclick = () => multiURL && window.open(multiURL, "_blank");
});
</script>
</body>
</html>
